import os
import sys
from typing import Optional

from langchain_community.utilities import SQLDatabase
# NOTE: Use the new class name from langchain_community.tools
from langchain_community.tools import QuerySQLDatabaseTool

from langchain_huggingface import HuggingFacePipeline
from langchain.chains import create_sql_query_chain
from langchain_core.prompts import PromptTemplate
from langchain_core.output_parsers import StrOutputParser

from sqlalchemy import create_engine
import langchain
langchain.debug = True

##############################
# TINYLLAMA LOAD
##############################
import torch
from transformers import AutoTokenizer, AutoModelForCausalLM, pipeline

MODEL_NAME = "TinyLlama/TinyLlama-1.1B-Chat-v1.0"


def load_tinyllama_langchain_llm():
    print("‚è≥ Loading TinyLlama model (HuggingFace style)...")
    tokenizer = AutoTokenizer.from_pretrained(MODEL_NAME)
    model = AutoModelForCausalLM.from_pretrained(
        MODEL_NAME,
        torch_dtype=torch.float16,
        device_map="auto",
    )
    print("‚úÖ Model loaded!")

    hf_pipe = pipeline(
        "text-generation",
        model=model,
        tokenizer=tokenizer,
        max_new_tokens=128,
        temperature=0.7,
        top_p=0.9,
        pad_token_id=tokenizer.eos_token_id,
        do_sample=False,  # optional: more deterministic
    )
    # Convert to a LangChain-compatible LLM
    llm = HuggingFacePipeline(pipeline=hf_pipe)
    return llm


def pick_tables(question: str, all_tables: list) -> list:
    """
    Basic approach: pick tables whose names appear in the user's question.
    If none found, pick first 3. 
    """
    question_lower = question.lower()
    relevant = [t for t in all_tables if t.lower() in question_lower]
    return relevant or all_tables[:3]


def main():
    # 1) Load TinyLlama model
    llm = load_tinyllama_langchain_llm()

    # 2) MySQL credentials
    user = "root"
    password = "admin"
    host = "localhost"
    port = 3306
    database = "chatbot"

    db_uri = f"mysql+pymysql://{user}:{password}@{host}:{port}/{database}"

    print("\nüîπTinyLlama Chat w/ MySQL (Only raw DB data printed)\n")
    print("Type 'exit' or 'quit' to stop.\n")

    # Build a "wide" DB object for table discovery
    wide_db = SQLDatabase.from_uri(db_uri)
    all_table_names = wide_db.get_usable_table_names()

    # Use the new tool class name: QuerySQLDatabaseTool
    query_tool = QuerySQLDatabaseTool(db=wide_db)

    # Minimal prompt to ensure the chain only outputs SQL
    minimal_sql_prompt = PromptTemplate.from_template(
        "Generate a valid MySQL query for the user question:\n{question}\n\n"
        "Only output the SQL query. Nothing else."
    )

    while True:
        question = input("User Question: ")
        if question.strip().lower() in ["exit", "quit"]:
            break

        # 3) pick relevant tables
        relevant_tables = pick_tables(question, all_table_names)
        print(f"[DEBUG] Using tables: {relevant_tables}")

        # 4) reflect columns only for those tables
        filtered_db = SQLDatabase.from_uri(db_uri, include_tables=relevant_tables)

        # 5) create a chain for text->SQL
        chain = create_sql_query_chain(
            llm=llm,
            db=filtered_db,
            prompt=minimal_sql_prompt
            # no 'output_parser' argument here, since your version doesn't support it
        )

        try:
            # 6) run the chain with the user question -> gets a raw string
            sql_query_raw = chain.invoke({"question": question})
            # If the chain returns extra text, parse it:
            sql_query = StrOutputParser().parse(sql_query_raw)

            print(f"\n[DEBUG] Generated SQL Query:\n{sql_query}\n")

            # 7) Execute the query
            rows = query_tool.run(sql_query)
            # 8) Print the DB results directly
            print("DB Results:\n")
            print(rows)

        except Exception as e:
            print(f"\n‚ùå Error: {e}")

    print("üëã Exiting. Goodbye!")


if __name__ == "__main__":
    main()
